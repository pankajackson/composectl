#!/usr/bin/env python

import argparse
import subprocess
import yaml
import os
from pathlib import Path
from enum import Enum
from dataclasses import dataclass
import re


class Action(str, Enum):
    UP = "up -d"
    STOP = "stop"
    RESTART = "restart"
    DOWN = "down -v"
    LS = "ls"
    LOGS = "logs"
    STATUS = "status"


@dataclass
class Network:
    name: str
    driver: str


@dataclass
class Service:
    name: str
    path: Path
    status: str | None = None


class ComposeCtl:
    def __init__(self, compose_dir: Path = Path("compose").absolute()):
        self.config = self.load_config()
        self.network = self.load_network()
        self.compose_dir = compose_dir.absolute()
        self.services = self.load_services()

    def load_config(self):
        config_path = "config.yaml"
        if os.path.exists(config_path):
            with open(config_path, "r") as file:
                return yaml.safe_load(file)
        return {}

    def load_network(self):
        network = self.config.get("network", {})
        if network:
            return Network(name=network["name"], driver=network["driver"])
        return Network(name="compose_ctl_default", driver="bridge")

    def create_network(self):
        result = subprocess.run(
            ["docker", "network", "ls", "--format", "{{.Name}}"],
            check=True,
            capture_output=True,
            text=True,
        )

        existing_networks = result.stdout.splitlines()

        if self.network.name not in existing_networks:
            print(
                f"Creating network '{self.network.name}' with driver '{self.network.driver}'"
            )
            subprocess.run(
                [
                    "docker",
                    "network",
                    "create",
                    "--driver",
                    self.network.driver,
                    self.network.name,
                ],
                check=True,
            )
        # else:
        #     print(f"Network '{self.network.name}' already exists.")

    def load_services(self):
        svc = os.listdir(self.compose_dir)
        svc_object_list = [
            Service(name=svc, path=self.compose_dir / svc) for svc in svc
        ]
        return svc_object_list

    def execute(self, service: Service, action: Action):
        if service.path.exists():
            print(
                f"Running: docker compose -f {service.path}/docker-compose.yml {action.value}"
            )
            subprocess.run(
                [
                    "docker",
                    "compose",
                    "-f",
                    f"{service.path}/docker-compose.yml",
                ]
                + action.value.split(" "),
                check=True,
                env={"CONTAINER_NETWORK": self.network.name},
            )
        else:
            print(f"Service '{service.name}' not found in '{self.compose_dir}'")

    def run(self, action: Action, service_name_list: list[str] | None = None):
        if action in [Action.UP, Action]:
            self.create_network()
        if not service_name_list:
            if action in [Action.UP, Action.RESTART, Action.LOGS]:
                services = [
                    svc
                    for svc in self.services
                    if svc.name in self.config.get("services", {}).get("enable", [])
                ]
            else:
                services = self.services
        else:
            services = [
                next(svc for svc in self.services if svc.name == svc_str)
                for svc_str in service_name_list
            ]
        for service in services:
            self.execute(service=service, action=action)

    def apply(self):
        active_services = [
            svc
            for svc in self.services
            if svc.name in self.config.get("services", {}).get("enable", [])
        ]
        inactive_services = [
            svc
            for svc in self.services
            if svc.name in self.config.get("services", {}).get("disable", [])
        ]
        if inactive_services:
            for svc in inactive_services:
                self.execute(service=svc, action=Action.STOP)
        if active_services:
            self.create_network()
            for svc in active_services:
                self.execute(service=svc, action=Action.UP)

    def list_services(self):
        print("Available services:")
        for service in self.services:
            print(f"  - {service.name}")

    def get_status(self):
        # Run docker compose ls and capture output
        result = subprocess.run(
            ["docker", "compose", "ls"], check=True, capture_output=True, text=True
        )

        running_services = {}
        lines = result.stdout.split("\n")

        for line in lines[1:]:  # Skip header
            parts = re.split(r"\s{2,}", line.strip())  # Split on multiple spaces
            if len(parts) >= 3:
                project_name, status, compose_file_path = parts[:3]

                # Extract running replica count from status if present (e.g., running(1))
                match = re.search(r"running\((\d+)\)", status)
                replica_count = match.group(1) if match else "?"

                running_services[project_name] = {
                    "status": (
                        f"running({replica_count})" if "running" in status else status
                    ),
                    "compose_file_path": Path(compose_file_path),
                }

        # Categorize services into managed and unmanaged
        managed_services = []
        unmanaged_services = []

        for name, service in running_services.items():
            if any(
                svc.name == name and svc.path == service["compose_file_path"].parent
                for svc in self.services
            ):  # Check if in compose directory
                managed_services.append(
                    (name, service["compose_file_path"], service["status"])
                )
            else:
                unmanaged_services.append(
                    (name, service["compose_file_path"], service["status"])
                )
        return managed_services, unmanaged_services

    def show_status(self, global_status=False):
        """Show status of services. If global_status is True, lists all projects; otherwise, only those in compose directory."""
        managed_services, unmanaged_services = self.get_status()

        # Print managed services
        print("Service Status:")
        for name, path, status in sorted(managed_services):
            print(f"  - {name}: {status}")

        # Print unmanaged services
        if unmanaged_services:
            print("\nUnmanaged Service Status:")
            for name, path, status in sorted(unmanaged_services):
                print(f"  - {name} ({path}): {status}")


def get_parser_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Manage Docker Compose services")
    parser.add_argument(
        "action",
        choices=["up", "down", "restart", "status", "ls", "logs", "stop", "apply"],
        help="Action to perform",
    )
    parser.add_argument(
        "services", nargs="*", help="Optional list of services to manage"
    )

    return parser.parse_args()


def main():
    args = get_parser_args()
    cctl = ComposeCtl()

    action_map = {
        "up": cctl.run,
        "stop": cctl.run,
        "down": cctl.run,
        "restart": cctl.run,
        "logs": cctl.run,
        "apply": cctl.apply,
        "status": cctl.show_status,
        "ls": cctl.list_services,
    }
    if args.action in action_map:
        if args.action in ["up", "down", "restart", "logs", "stop"]:
            action_map[args.action](Action[args.action.upper()], args.services)
        else:
            action_map[args.action]()


if __name__ == "__main__":
    main()
