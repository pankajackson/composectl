#!/usr/bin/env python

import argparse
import subprocess
import yaml
import os
from pathlib import Path
from enum import Enum
from dataclasses import dataclass
import re


class Action(str, Enum):
    LS = "ls"
    UP = "up -d"
    DOWN = "down -v"
    RESTART = "restart"
    LOGS = "logs"
    STATUS = "status"


@dataclass
class Network:
    name: str
    driver: str


@dataclass
class Service:
    name: str
    path: Path
    status: str | None = None


class ComposeCtl:
    def __init__(self, compose_dir: Path = Path("compose").absolute()):
        self.config = self.load_config()
        self.network = self.load_network()
        self.compose_dir = compose_dir.absolute()
        self.services = self.load_services()

    def load_config(self):
        config_path = "config.yaml"
        if os.path.exists(config_path):
            with open(config_path, "r") as file:
                return yaml.safe_load(file)
        return {}

    def load_network(self):
        network = self.config.get("network", {})
        if network:
            return Network(name=network["name"], driver=network["driver"])
        return Network(name="compose_ctl_default", driver="bridge")

    def load_services(self):
        svc = os.listdir(self.compose_dir)
        svc_object_list = [
            Service(name=svc, path=self.compose_dir / svc) for svc in svc
        ]
        return svc_object_list

    def run(self, action: Action, service_name_list: list[str] | None = None):
        if not service_name_list:
            services = self.services
        else:
            services = [
                next(svc for svc in self.services if svc.name == svc_str)
                for svc_str in service_name_list
            ]
        for service in services:
            if service.path.exists():
                print(
                    f"Running: docker compose -f {service.path}/docker-compose.yml {action.value}"
                )
                subprocess.run(
                    [
                        "docker",
                        "compose",
                        "-f",
                        f"{service.path}/docker-compose.yml",
                    ]
                    + action.value.split(" "),
                    check=True,
                    env={"CONTAINER_NETWORK": self.network.name},
                )
            else:
                print(f"Service '{service.name}' not found in '{self.compose_dir}'")

    def list_services(self):
        print("Available services:")
        for service in self.services:
            print(f"  - {service.name}")

    def show_status(self, global_status=False):
        """Show status of services. If global_status is True, lists all projects; otherwise, only those in compose directory."""

        # Run docker compose ls and capture output
        result = subprocess.run(
            ["docker", "compose", "ls"], check=True, capture_output=True, text=True
        )

        running_services = {}
        lines = result.stdout.split("\n")

        for line in lines[1:]:  # Skip header
            parts = re.split(r"\s{2,}", line.strip())  # Split on multiple spaces
            if len(parts) >= 3:
                project_name, status, compose_file_path = parts[:3]

                # Extract running replica count from status if present (e.g., running(1))
                match = re.search(r"running\((\d+)\)", status)
                replica_count = match.group(1) if match else "?"

                running_services[project_name] = {
                    "status": (
                        f"running({replica_count})" if "running" in status else status
                    ),
                    "compose_file_path": Path(compose_file_path),
                }

        # Categorize services into managed and unmanaged
        managed_services = []
        unmanaged_services = []

        for name, service in running_services.items():
            if any(
                svc.name == name and svc.path == service["compose_file_path"].parent
                for svc in self.services
            ):  # Check if in compose directory
                managed_services.append(
                    (name, service["compose_file_path"], service["status"])
                )
            else:
                unmanaged_services.append(
                    (name, service["compose_file_path"], service["status"])
                )

        # Print managed services
        print("Service Status:")
        for name, path, status in sorted(managed_services):
            print(f"  - {name}: {status}")

        # Print unmanaged services
        if unmanaged_services:
            print("\nUnmanaged Service Status:")
            for name, path, status in sorted(unmanaged_services):
                print(f"  - {name} ({path}): {status}")


def get_parser_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Manage Docker Compose services")
    parser.add_argument(
        "action",
        choices=["up", "down", "restart", "status", "ls", "logs"],
        help="Action to perform",
    )
    parser.add_argument(
        "services", nargs="*", help="Optional list of services to manage"
    )

    return parser.parse_args()


def main():
    args = get_parser_args()
    cctl = ComposeCtl()

    action_map = {
        "up": cctl.run,
        "down": cctl.run,
        "restart": cctl.run,
        "logs": cctl.run,
        "status": cctl.show_status,
        "ls": cctl.list_services,
    }
    if args.action in action_map:
        if args.action in ["up", "down", "restart", "logs"]:
            action_map[args.action](Action[args.action.upper()], args.services)
        else:
            action_map[args.action]()


if __name__ == "__main__":
    main()
