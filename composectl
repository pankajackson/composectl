#!/usr/bin/env python

import argparse
import subprocess
import yaml
import os
from pathlib import Path
from enum import Enum
from dataclasses import dataclass
import re
from tabulate import tabulate


class Action(str, Enum):
    UP = "up -d"
    STOP = "stop"
    RESTART = "restart"
    DOWN = "down -v"
    LS = "ls"
    LOGS = "logs"
    STATUS = "status"


@dataclass
class Network:
    name: str
    driver: str


@dataclass
class Service:
    name: str
    path: Path
    status: str | None = None


class ComposeCtl:
    def __init__(
        self,
        compose_dir: Path = Path("compose").absolute(),
        dry_run: bool = False,
    ):
        self.config = self.load_config()
        self.dry_run = dry_run
        self.network = self.load_network()
        self.compose_dir = compose_dir.absolute()
        self.services = self.load_services()

    def load_config(self):
        config_path = "config.yaml"
        if os.path.exists(config_path):
            with open(config_path, "r") as file:
                return yaml.safe_load(file)
        return {}

    def load_network(self):
        network = self.config.get("network", {})
        if network:
            return Network(name=network["name"], driver=network["driver"])
        return Network(name="compose_ctl_default", driver="bridge")

    def create_network(self):
        is_network_exist = subprocess.run(
            ["docker", "network", "inspect", self.network.name],
            check=False,
            capture_output=True,  # To suppress unnecessary output
        )

        if is_network_exist.returncode != 0:  # Network does not exist
            cmd = [
                "docker",
                "network",
                "create",
                "--driver",
                self.network.driver,
                self.network.name,
            ]
            if self.dry_run:
                print(f"[DRY RUN] Would run: {" ".join(cmd)}")
            else:
                print(f"Running: {" ".join(cmd)}")
                subprocess.run(
                    cmd,
                    check=True,
                )
        # else:
        #     print(f"Network '{self.network.name}' already exists.")

    def load_services(self):
        svc = os.listdir(self.compose_dir)
        svc_object_list = [
            Service(name=svc, path=self.compose_dir / svc) for svc in svc
        ]
        return svc_object_list

    def execute(self, service: Service, action: Action):
        if service.path.exists():

            cmd = [
                "docker",
                "compose",
                "-f",
                f"{service.path}/docker-compose.yml",
            ] + action.value.split(" ")
            if self.dry_run:
                print(f"[DRY RUN] Would run: {" ".join(cmd)}")
            else:
                print(f"Running: {" ".join(cmd)}")
                subprocess.run(
                    cmd,
                    check=True,
                    env={"CONTAINER_NETWORK": self.network.name},
                )
        else:
            print(f"Service '{service.name}' not found in '{self.compose_dir}'")

    def run(self, action: Action, service_name_list: list[str] | None = None):
        if action in [Action.UP, Action.RESTART]:
            self.create_network()
        if not service_name_list:
            if action in [Action.UP, Action.RESTART, Action.LOGS]:
                services = [
                    svc
                    for svc in self.services
                    if svc.name in self.config.get("services", {}).get("enable", [])
                ]
            else:
                services = self.services
        else:
            services = [svc for svc in self.services if svc.name in service_name_list]
        for service in services:
            self.execute(service=service, action=action)

    def apply(self):
        active_services = [
            svc
            for svc in self.services
            if svc.name in self.config.get("services", {}).get("enable", [])
        ]
        inactive_services = [
            svc
            for svc in self.services
            if svc.name in self.config.get("services", {}).get("disable", [])
        ]
        if inactive_services:
            for svc in inactive_services:
                self.execute(service=svc, action=Action.STOP)
        if active_services:
            self.create_network()
            for svc in active_services:
                self.execute(service=svc, action=Action.UP)

    def list_services(self):
        print("Available services:")
        for service in self.services:
            print(f"  - {service.name}")

    def get_status(self):
        # Run docker compose ls and capture output
        result = subprocess.run(
            ["docker", "compose", "ls"], check=True, capture_output=True, text=True
        )

        running_services = {}
        lines = result.stdout.split("\n")

        for line in lines[1:]:  # Skip header
            parts = re.split(r"\s{2,}", line.strip())  # Split on multiple spaces
            if len(parts) >= 3:
                project_name, status, compose_file_path = parts[:3]

                # Extract running replica count from status if present (e.g., running(1))
                match = re.search(r"running\((\d+)\)", status)
                replica_count = match.group(1) if match else "?"

                running_services[project_name] = {
                    "status": (
                        f"running({replica_count})" if "running" in status else status
                    ),
                    "compose_file_path": Path(compose_file_path),
                }

        # Categorize services into managed and unmanaged
        managed_services = []
        unmanaged_services = []

        for name, service in running_services.items():
            if any(
                svc.name == name and svc.path == service["compose_file_path"].parent
                for svc in self.services
            ):  # Check if in compose directory
                managed_services.append(
                    (name, service["compose_file_path"], service["status"])
                )
            else:
                unmanaged_services.append(
                    (name, service["compose_file_path"], service["status"])
                )
        return managed_services, unmanaged_services

    def show_status(self):
        """Show status of services. If global_status is True, lists all projects; otherwise, only those in compose directory."""
        managed_services, unmanaged_services = self.get_status()

        print("Service Status:")
        print(
            tabulate(
                managed_services, headers=["Name", "Path", "Status"], tablefmt="grid"
            )
        )
        print("\nUnmanaged Service Status:")
        print(
            tabulate(
                unmanaged_services, headers=["Name", "Path", "Status"], tablefmt="grid"
            )
        )


def get_parser_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Manage Docker Compose services")
    parser.add_argument(
        "action",
        choices=["up", "down", "restart", "status", "ls", "logs", "stop", "apply"],
        help="Action to perform",
    )
    parser.add_argument(
        "services", nargs="*", help="Optional list of services to manage"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Only show commands without executing",
        default=False,
    )

    return parser.parse_args()


def main():
    args = get_parser_args()
    cctl = ComposeCtl(dry_run=args.dry_run)

    action_map = {
        "up": cctl.run,
        "stop": cctl.run,
        "down": cctl.run,
        "restart": cctl.run,
        "logs": cctl.run,
        "apply": cctl.apply,
        "status": cctl.show_status,
        "ls": cctl.list_services,
    }
    if args.action in action_map:
        if args.action in ["up", "down", "restart", "logs", "stop"]:
            action_map[args.action](Action[args.action.upper()], args.services)
        else:
            action_map[args.action]()


if __name__ == "__main__":
    main()
